## 📚 개요

### 🎯 설계의 목표
> 지금 제 역량으로는 하루 만에 모든 것을 설계할 수는 없습니다. 그렇다고 해서 이 설계를 7일에 걸쳐서 하는 건 주객이 전도되었다고 생각합니다. 그래서 목적을 정확하게 잡고 넘어가고자 합니다.

<br/>

| 목표                            | 이유                                                                                                                                                                                                                                    |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 이번 미션을 통해 실전적인 감각을 익히기        | ▸ 멤버십에 들어오고 나서 많은 방황을 했습니다.<br/><br/>▸ 그에 따라서 요구사항을 주어진 시간에 명확하게 구현을 해야한다는 개발자의 필수 덕목을 놓히고 있었습니다.<br/><br/>▸ 이번 기회에 제 장점을 극대화하고, 단점은 최소화하는 방법을 터득하고자 합니다.<br/>▸ 그리고 나아가 실무에서도 지속적으로 성장할 수 있는 방법을 고안했기에, 저를 대상으로 이게 과연 맞는지 실험해보고자 합니다. |
| 요구사항 분석                       | ▸ 멤버십에 들어오고 요구사항에 대한 분석 능력이 상당히 떨어졌다는 생각이 듭니다.<br/><br/>▸ 마침 리액트 활용하기가 목표이고, 앞에서 언급한 실무적인 성장 역량 기르기라는 컨셉에 맞춰서 제가 무엇을 해야하는지 명확히 하고자 합니다.<br/><br/>▸ 요구사항 분석을 통해서 처음에 길을 제대로 파악하고, 이를 바탕으로 일정을 추출하여 길을 찾기 위한 자료로 활용하고자 합니다.             |
| 내가 주어진 시간에 얼마만큼 할 수 있는지 역량 파악 | ▸ 1MH 등의 단위가 있습니다. 제가 주어진 시간에 얼마만큼 집중하여 작업을 낼 수 있는지 파악하는게 이번 미션에서 제가 잡은 주안점입니다.<br/><br/>▸ 이에 대한 정량적 평가를 위해서는 기준이 필요합니다. <br/><br/>▸ 이를 위해서 설계를 진행하고자 합니다.                                                                            |

<br/>

### 🤔 주의사항
- 지금 제 역량으로 설계를 하루 아침에 할 수 없습니다.
- 설계는 구현하면서 바뀔 수 있습니다.(폭포수 모델의 시대는 지났습니다.)
- 항상 어느 하나에 매몰되는게 있는데, 이는 제가 목표하는 바와는 다릅니다. 그렇기에 월요일 단 하루만 계획을 하는 데 사용하고자 합니다.

<br/><br/><br/>

## 📚 설계에 앞선 나의 문제 접근 방법
항상 저는 다음과 같은 방법을 통해서 문제를 바라봅니다. <br/><br/>

1. 입력과 출력 파악
2. 자료구조 추출
3. 알고리즘 파악

<br/><br/>

이에 따라서, 미션을 바라봤었는데, `FE`는 `UI/UX`라는 요소가 존재하기에 조금은 다르게 파악할 필요가 있었습니다.<br/><br/>

이에 따라서 컴포넌트 기반으로 나누게 되었습니다.<br/><br/>

또한, 지난 2 주간 학습한 리액트의 핵심원리를 바탕으로 리액트의 개발 철학에 맞추어서 사고하고자 했습니다. 고려한 요소는 아래와 같습니다.<br/>
1. 리액트는 단방향 흐름을 지향합니다.
2. 선언형 프로그래밍을 지향합니다.
3. 가상 돔에 기반해서 처리를 하며, 가상 돔을 실제 돔에 붙이는 과정은 리액트가 알아서 처리해줍니다.<br/><br/><br/>

## 📝 설계 방법
설계는 다음과 같은 방식으로 진행되었습니다.<br/><br/>

`큰 그림` -> `중간 그림` -> `작은 그림` 순서로 이어가고자 했으며 이는 각각 `L`, `M`, `S` 로 구분하여 서술합니다.<br/><br/>

즉, `Divide And Conquer`방식을 채택하였으며, 사실 이게 제가 생각하는 방식이기도 합니다.<br/><br/>

### ⚙️ 서버와 클라이언트 구조에서의 분할 :: 백앤드 설계 방법

- 큰 그림으로는 서버와 클라이언트의 전체 인프라를 먼저 생각했습니다.
- 사실 뉴스레터에 많은 기능이 요구 되지 않아서, 간단한 테스트 데이터 전송을 위한 BE를 구축하고자 했습니다.
- 이에 따라서, 필요한 데이터를 뽑아서 데이터베이스를 설계했습니다. (이후 서술할 BE 설계 참고)
- 그리고, 이 데이터를 통신하기 위한 API를 설계하였습니다.
<br/><br/>

백앤드를 먼저 설계를 하였습니다. 그리고 프론트앤드 설계를 하다보니, 더 많은 데이터나 통신이 요구되었습니다. 다만, 설계는 완벽한 시스템 청사진을 그리려는 것이 아닌, 정량적 평가를 위한 일정 산출 목적이기에 이정도면 충분하다고 생각되어 나머지는 이후 개발을 진행하면서 수정해나가고자 합니다.
<br/><br/>

### ⚙️ 프론트앤드 설계 방법

- 컴포넌트 기반으로 사고하였습니다.
- 우선 필요한 컴포넌트를 돔 트리 형태로 뽑아냈습니다.
- 그리고 각 컴포넌트에 필요한 상태를 뽑아냈습니다.
- 마지막으로 이벤트나 통신 등의 동적인 기능을 뽑아냈습니다.

<br/><br/>

이 과정에서 이벤트의 위임이나 상태관리의 위임은 전적으로 리액트의 `단방향 흐름` 개발 철학에 입각하여 판단하였습니다.<br/>
만약, 자식 컴포넌트가 부모 컴포넌트의 데이터를 참조해야한다면, 그리고 이게 `props`등으로 단방향 처리가 되지 않는다면 직속 부모 컴포넌트에게 상태 관리나 이벤트를 위임했습니다.<br/>
그러고도 더 상위 레벨이 필요하면 상위의 컴포넌트에 위임하는 형태로 진행했습니다.<br/><br/>

이렇게 함으로써 `props drilling` 문제는 발생하지만, `단방향 흐름`은 유지될 수 있도록 하였습니다.<br/>
전역 상태 관리 방법도 있지만, 제가 집중하려는 요소가 아니기도 하고 지금 단계에서는 굳이 필요성을 느끼지 못해 `단방향 흐름`에만 집중하고자 했습니다.

<br/><br/><br/>

## 💾 BE 설계
### ⚙️ 백앤드 설계 개요
- BE는 후순위 구현사항입니다.<br/>
- 그러나 간단한 테스트 환경 정도는 구축하고자 하빈다.<br/>
- 기본적으로, DB 자체를 사용하기 보다는 DB를 설계해두고 이를 위한 가상의 객체를 만들어서 처리를 하는 방식으로 진행하려 했습니다.<br/>
- 이후에 시간적 여유가 남으면 DB를 활용하기로 했습니다.<br/><br/><br/>

### ⚙️ 백앤드 개발 환경

| 환경         | 설명                            |
| ---------- | ----------------------------- |
| Node.js    | 백앤드 기본 런타임 환경                 |
| Express.js | 백앤드 설정을 위한 프레임워크              |
| MySQL      | 데이터 저장을 위한 SQL 기반의 관계형 데이터베이스 |

<br/><br/><br/>

### ⚙️ DB 설계
- DB 설계 내용은 아래와 같습니다.<br/><br/>

![DB 설계 내용](DB%20설계.png)

<br/><br/>

- 위 내용을 표로 바꿔보면 다음과 같습니다.

<br/><br/>

#### 💽 언론사 정보(PRESS) 데이터베이스
| 언론사 이름:press_name                          | 로고:logo                        | 주소:address                     |
| ------------------------------------------ | ------------------------------ | ------------------------------ |
| char(50) <br/><br>NOT NULL <br/><br>PK, FK | char(300)<br/><br><br>NOT NULL | char(300)<br/><br><br>NOT NULL |

<br/>

- 로고는 언론사 로고 이미지로, 로컬에 저장된 이미지를 참고하여 사용합니다. (혹은 언론사 이미지 사이트가 있으면 그 주소를 이용합니다.)
- 주소는 언론사 주소를 의미합니다.

<br/><br/>

#### 💽 유저 정보(USER)

| 유저 ID: user_id                                     | 비밀번호: password             | 이메일: email                |
| -------------------------------------------------- | -------------------------- | ------------------------- |
| char(50) <br/><br><br>NOT NULL <br/><br><br>PK, FK | char(128)<br/><br>NOT NULL | char(50)<br/><br>NOT NULL |

<br/>

- 비밀번호는 md5로 암호화합니다.

<br/><br/>

#### 💽 구독리스트(SUBSCRIBE)
| 언론사 이름:press_name                       | 유저 ID: user_id                          |
| --------------------------------------- | --------------------------------------- |
| char(50)<br/><br>NOT NULL<br/><br>PK,FK | char(50)<br/><br>NOT NULL<br/><br>PK,FK |

<br/>

- 언론사 이름과 유저 ID는 각각의 테이블에 대해서 다대다 관계입니다.
- 이들은 둘이 합쳐서 하나의 PK를 이룹니다.

<br/><br/><br/>

### ⚙️ API 설계

| 설명                       | HTTP Method | API 경로                           |
| ------------------------ | ----------- | -------------------------------- |
| 뉴스래터 정보 전체 요청            | GET         | api/press                        |
| 특정 유저의 즐겨찾기 정보 가져오기      | GET         | api/subscribe/:userID            |
| 특정 유저의 즐겨찾기 등록하기         | POST        | api/subscribe                    |
| 특정 유저의 특정 뉴스레터 즐겨찾기 삭제하기 | DELETE      | api/subscribe/:userID/:pressName |

<br/>

- 테스트를 위한 최소한의 기능만 구현합니다.

## 🖥️ FE 설계
> 설계 방법에 대한 부분은 `⚙️ 프론트앤드 설계 방법`를 참조해주세요.

### ⚙️ 프론트앤드 개발 환경

| 환경               | 설명                                                   |
| ---------------- | ---------------------------------------------------- |
| React            | ▸ VDOM에 기반한 SPA 라이브러리                                |
| Vite             | ▸ JS 빌드 도구<br/><br/>▸ React, TS, Jest 등의 빌드 및 번들링 위함 |
| TypeScript       | ▸ 정적 타입 분석 언어이자 트랜스파일러                               |
| Jest             | ▸ React, TS 테스트 도구                                   |
| ESLint, Prettier | ▸ JS, TS 코드 포메터<br/><br/>▸ `Airbnb` 컨벤션을 따름          |

### 🤔 컴포넌트의 분석
![전체 구조](전체_구조.png)

<br/>

- 뉴스 스탠드 자체를 하나의 컴포넌트로 취급합니다.(`Newsstand` 컴포넌트)

![뉴스스탠드 자식 구조](뉴스스탠드_자식구조.png)

- 이 컴포넌트 내부에 피그마에 제시된 것처럼 3가지 자식 컴포넌트가 있다고 간주합니다.

<br/><br/>

| 번호  | 컴포넌트 명 | 설명                           |
| --- | ------ | ---------------------------- |
| 1   | Header | ▸ 뉴스 스탠드의 헤더입니다.             |
| 2   | Banner | ▸ 최신 뉴스 정보를 롤링해서 표현하는 배너입니다. |
| 3   | Main   | ▸ 언론사 정보가 담긴 컴포넌트입니다.        |

<br/><br/>

우선 위와 같이 3가지 형식으로 나눠서 생각을 하였습니다.<br/>
이를 트리구조로 바꿔보면 다음과 같습니다.<br/><br/>

![뉴스스탠드_트리구조](뉴스스탠드_트리구조.png)

<br/>

그리고 각각의 요소를 다시 `L`로 삼아서 진행하였습니다. <br/><br/>

### 🧑‍💻 `Header` 컴포넌트
헤더컴포넌트는 분석하면 다음과 같이 표현이 가능했습니다. <br/>

![헤더 자식구조](헤더_자식구조.png)

<br/>

이를 트리구조로 표현하면 다음과 같습니다. <br/>

![헤더 트리구조](헤더_트리구조.png)

<br/>

그리고 여기에 명시된 상태를 입히면 다음과 같이 표현이 가능합니다. <br/>

![헤더 상태표시](헤더_상태표시.png)

<br/>

상태까지는 간단했습니다. <br/>
이벤트를 붙이는 과정에 문제가 발생했습니다. 뉴스스탠드를 클릭하면 화면을 새로고침 해야했기 때문입니다.<br/>
사실 여기서 화면은 `Root`인 `Newsstand` 컴포넌트를 말합니다.<br/>
이 컴포넌트가 리랜더링 될 필요가 있었습니다.<br/><br/>

당초, 리액트의 개발 철학인 `단방향 흐름`을 따라간다고 했습니다. <br/>
이에 따라 다음과 같은 사고를 하게 되었습니다.<br/><br/>

Rendering을 유발하는 코드가 필요<br/>-> React는 단방향 흐름(역으로 가급적 흐르면 안됨)<br/>-> `onClick` 이벤트가 전체 언론사의 업데이트를 유발해야 함<br/>-> `event`는 그러면 리랜더링의 대상이 되는 곳에 배치(`useState` 등으로 해당 요소를 변경하면 휴리스틱 알고리즘에 의해 연관된 게 다 변경되기에..)<br/>-> `root` 에 배치 <br/><br/>

이런 흐름으로 인해서 해당 이벤트를 `root(Newstand 컴포넌트)`에 위임하게 되었습니다.<br/><br/>

이를 표현하면 아래와 같습니다.<br/><br/>

![헤더_이벤트](헤더_이벤트.png)

<br/><br/><br/>

### 🧑‍💻 `Banner` 컴포넌트
![베너 자식구조](베너_자식구조.png)

<br/>

베너 자식구조는 위와 같이 표현할 수 있습니다.<br/>
그리고 이걸 트리구조로 바꾸면 다음과 같습니다. <br/><br/>

![베너 트리구조](베너_트리구조.png)

<br/><br/>

그리고 여기에 상태를 붙여보면 다음과 같습니다.<br/><br/>

![배너 상태표시](배너_상태표시.png)

<br/>

이 역시도 단방향으로 흐를 수 있게 하기로 했습니다.<br/>
그리고 통신을 어떻게 하면 최소화할 수 있을까 고민을 하였는데, 그 결과가 위의 그림입니다.<br/><br/>

뉴스정보의 경우 `Banner`에서 10개를 한번에 가져온다. 이를 통해서 단 한번만 통신할 수 있도록 합니다.<br/>
이렇게 가져온 정보를 부모가 자식 컴포넌트들에게 5개씩 분배합니다.<br/><br/>

타이머의 경우도 `옵저버 패턴` 혹은 `구독 패턴`을 이용합다. `Rolling`이 `Banner`를 구독하고 있고, 타이머 자체는 `Banner`에서 돕니다.<br/>
 `Banner`는 매 초마다 혹은 특정 기준마다 `Rolling`에게 상태를 알립니다. (이 기준은 구현단계에서 최적화해보고자 합니다.)<br/>
 그러면 `Rolling`은 `Hover`이벤트가 없는 경우 회전을 합니다.<br/>
 `Hover`이벤트 동안은 `preventDefault`나 여러 옵션을 통해서 롤링 이벤트를 막을 예정입니다<br/><br/>
 - 이벤트 덮어쓰기가 키워드가 될 듯 합니다.<br/><br/>

그렇게 관련된 롤링 이벤트를 추가하면 다음과 같습니다.<br/><br/>

![배너 이벤트](배너_이벤트.png)<br/><br/><br/>

## 🤔 일정 산출에 앞서서
- 여기까지 분석하고, 계획하다보니 꽤나 시간이 많이 걸렸습니다.
- 그래서 여기까지만 하고, 구현을 최대한 빨리 진행한 다음에 `Main`에 대한 부분은 이후 다시 설계하고자 합니다.
<br/><br/>
처음에는 다 할 수 있을 줄 알았지만 못하게 된 원인을 분석해본 결과 다음과 같습니다.<br/><br/>

| 원인                            | 설명                                                                                                                                                                                              | 해결방안                                                                                                                                                                                                     |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 방법을 몰랐습니다.                    | ▸ 어떻게 설계를 해야할 지 방법을 몰랐고, 빠르게 그 길에 도달하는 법도 몰랐습니다.<br/><br/>▸ 지금 하는 방식은 맞으나 처음 시도해본 방법이라서 시간이 많이 소요되었습니다.                                                                                         | ▸ 이 방법 자체는 좋기 떄문에 익숙해질 필요가 있을 듯 합니다.<br/><br/>▸ 단순히 시간 문제일 뿐이라고 생각합니다.                                                                                                                                   |
| 핵심을 요약하지 못하고 너무 서술하듯이 설명했습니다. | ▸ 지금 본 내용 처럼 너무 서술이 길게 되었습니다.<br/><br/>▸ 긴 서술 방식은 설명하는 데에는 좋을 수 있으나, 시간과 비용적으로 너무 큰 자원을 요구합니다.<br/><br/>▸ 또한, 설계 문서의 경우에는 간략할 필요가 있습니다.<br/><br/>▸ 독자를 고려하지 못했을 뿐 아니라 제 스스로의 자원을 너무 많이 잡아먹었습니다. | ▸ 간략하게 서술하고자 합니다.<br/><br/>▸ 핵심만 딱 요약을 하는 것을 목표로 앞으로 훈련을 진행합니다.<br/><br/> 최대한 빠르게 간단하면서 명료하게 문서 작성하는 것을 연습합니다.                                                                                           |
| 스스로의 능력을 과신했습니다.              | ▸ 처음에는 이정도는 금방 끝나겠지 했습니다.<br/><br/>▸ 그런데 생각보다 많은 시간이 소요되었고, 부캠 내부적으로도 활동이 많았어서 절대적인 집중시간이 부족했습니다.<br/><br/>▸ 이런 요소까지 고려해서 완충 작용을 하는 시간을 뒀어야 했는데 그러지 못한 점이 아쉽습니다.                                | ▸ 앞으로 완충 시간을 두고자 합니다.<br/><br/>▸ 스스로의 역량이 생각 이상으로 작을 수 있겠다는 것을 배웠습니다.<br/><br/>▸ 능력부족일 수 있겠지만, 저도 사람이기에 피로나 주변 일정 등에 상당히 큰 영향을 받는 것 같습니다.<br/><br/>▸ 변수가 생겨도 대처할 수 있게 완충 시간을 잘 둬서 일정을 설정하는게 중요함을 깨달았습니다. |

<br/><br/>

## 📅 일정 산출
- 일정은 말 보다는 이미지가 편할 듯 하여 이미지를 첨부합니다.
- 현재 설계한 곳 까지의 일정을 산출하였습니다.
- 일단 1차적으로 진행을 하면서, 제가 어느정도 역량을 갖고 있는지, 달성을 했으면 왜 달성을 했으며 못하면 왜 못했는지를 제대로 파악하고 다음 일정을 계획해보고자 합니다.
- 지금 제 목표는 스스로에 대한 정량적인 메타인지이기에 한번에 다 계획하기 보다는 나눠서 계획하는게 좋다고 생각하였습니다.

